#!/usr/bin/env bash

#===============================================================================
# dotfiles.sh - Dotfiles Management Script for Arch Linux with Hyprland
#===============================================================================
# This script helps manage dotfiles by:
# 1. Initializing a dotfiles repository with existing configs
# 2. Installing dotfiles from the repository to the system
# 3. Updating the repository with the latest local changes
# 4. Backing up existing configs before overwriting
#
# Author: Richard Leite.
# Created: June 2025
#===============================================================================

# Exit on error
set -e

# Trap for cleanup
trap cleanup EXIT

# Check if running as root
check_root() {
  if [ "$EUID" -eq 0 ]; then
    log "error" "This script should not be run as root"
    exit 1
  fi

  # Check if we have sudo privileges
  if ! sudo -n true 2>/dev/null; then
    log "warn" "No sudo privileges detected. Some operations may fail."
  fi
}

# Verify dependencies
check_dependencies() {
  local required=("git" "rsync" "ln" "sudo" "pacman")
  local missing=()
  local retries=3
  local delay=2

  # Check dependencies
  for dep in "${required[@]}"; do
    if ! command -v "$dep" &>/dev/null; then
      missing+=("$dep")
    fi
  done

  if [ ${#missing[@]} -gt 0 ]; then
    log "error" "Missing dependencies: ${missing[*]}"

    # Attempt to install missing dependencies with retries
    local attempt=1
    while [ $attempt -le $retries ]; do
      log "info" "Attempt $attempt/$retries: Installing missing dependencies..."
      if sudo pacman -S --noconfirm "${missing[@]}"; then
        log "success" "Dependencies installed successfully"
        return 0
      else
        log "warn" "Attempt $attempt failed. Retrying in $delay seconds..."
        sleep $delay
        attempt=$((attempt + 1))
      fi
    done

    log "error" "Failed to install dependencies after $retries attempts"
    exit 1
  fi

  # Verify package versions
  for dep in "${required[@]}"; do
    if ! $dep --version >/dev/null 2>&1; then
      log "warn" "$dep version check failed"
    fi
  done
}

# Cleanup function
cleanup() {
  local temp_dir="/tmp/dotfiles-tmp-$$"
  if [ -d "$temp_dir" ]; then
    rm -rf "$temp_dir"
  fi
}

#===============================================================================
# Color definitions
#===============================================================================
# Force color output
if [ -t 1 ]; then
    # Use tput for better compatibility with different terminals
    if command -v tput >/dev/null 2>&1; then
        RED=$(tput setaf 1)
        GREEN=$(tput setaf 2)
        YELLOW=$(tput setaf 3)
        BLUE=$(tput setaf 4)
        MAGENTA=$(tput setaf 5)
        CYAN=$(tput setaf 6)
        NC=$(tput sgr0) # Reset color
    else
        # Fallback to ANSI color codes if tput is not available
        RED='\e[0;31m'
        GREEN='\e[0;32m'
        YELLOW='\e[0;33m'
        BLUE='\e[0;34m'
        MAGENTA='\e[0;35m'
        CYAN='\e[0;36m'
        NC='\e[0m' # Reset color
    fi
else
    # No colors if not a terminal
    RED='' GREEN='' YELLOW='' BLUE='' MAGENTA='' CYAN='' NC=''
fi

# ANSI color codes for logging
error() { printf "%b\n" "${RED}ERROR: $1${NC}" >&2; }
warn() { printf "%b\n" "${YELLOW}WARN: $1${NC}" >&2; }
success() { printf "%b\n" "${GREEN}SUCCESS: $1${NC}"; }
info() { printf "%b\n" "${BLUE}INFO: $1${NC}"; }
debug() { [ "$VERBOSE" -eq 1 ] && printf "%b\n" "${MAGENTA}DEBUG: $1${NC}" >&2; }
trace() { [ "$VERBOSE" -eq 1 ] && printf "%b\n" "${CYAN}TRACE: $1${NC}" >&2; }

#===============================================================================
# Script variables
#===============================================================================
DOTFILES_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/files"
REPO_ROOT="$(dirname "$DOTFILES_DIR")"
BACKUP_DIR="$REPO_ROOT/backups/$(date +%Y%m%d_%H%M%S)"
BACKUP_UPDATE_DIR="$BACKUP_DIR/update"
BACKUP_INSTALL_DIR="$BACKUP_DIR/install"
BACKUP_TYPE_UPDATE="update"
BACKUP_TYPE_INSTALL="install"
CONFIG_DIR="$HOME/.config"
CACHE_DIR="$REPO_ROOT/.cache"
VERBOSE=0
FORCE=0

# Cache variables
CACHE_FILE="$CACHE_DIR/dotfiles.cache"
CACHE_TIMEOUT=86400 # 24 hours in seconds

# Create cache directory
mkdir -p "$CACHE_DIR"

#===============================================================================
# Backup functions
#===============================================================================
backup() {
  local path="$1"
  local backup_type="$2"
  local max_backups=5

  # Validate input
  if [ -z "$path" ] || [ -z "$backup_type" ]; then
    log "error" "Backup requires path and backup_type"
    return 1
  fi

  # Create backup directory structure
  case "$backup_type" in
  $BACKUP_TYPE_UPDATE)
    backup_dir="$BACKUP_UPDATE_DIR"
    ;;
  $BACKUP_TYPE_INSTALL)
    backup_dir="$BACKUP_INSTALL_DIR"
    ;;
  *)
    log "error" "Invalid backup type: $backup_type"
    return 1
    ;;
  esac

  # Rotate backups (keep only max_backups)
  local backup_num=1
  while [ $backup_num -le $max_backups ]; do
    if [ $backup_num -eq $max_backups ]; then
      rm -rf "${backup_dir}_${backup_num}" 2>/dev/null || true
    else
      mv "${backup_dir}_${backup_num}" "${backup_dir}_$((backup_num + 1))" 2>/dev/null || true
    fi
    backup_num=$((backup_num + 1))
  done

  # Create new backup
  local backup_path="$backup_dir/$(basename "$path")"
  local backup_dirname="$(dirname "$backup_path")"

  # Create parent directory structure
  mkdir -p "$backup_dirname"

  # Use rsync for incremental backup with checksum verification
  local rsync_flags="-av --link-dest=$path --checksum"
  if [ "$VERBOSE" -eq 1 ]; then
    rsync_flags="$rsync_flags -v"
  fi

  if ! rsync $rsync_flags "$path" "$backup_path"; then
    log "error" "Failed to backup $path"
    return 1
  fi

  # Verify backup integrity
  if ! diff -q "$path" "$backup_path" >/dev/null 2>&1; then
    log "error" "Backup verification failed for $path"
    return 1
  fi

  # Compress backup if it's a directory
  if [ -d "$backup_path" ]; then
    local compressed_path="$backup_path.tar.gz"
    if tar -czf "$compressed_path" -C "$backup_dirname" "$(basename "$backup_path")"; then
      rm -rf "$backup_path"
      log "debug" "Compressed backup to $compressed_path"
    else
      log "warn" "Failed to compress backup"
    fi
  fi

  log "info" "Successfully backed up $path to $backup_path"
  return 0
}

backup_system_config() {
  local backup_dir="$BACKUP_DIR/system-config"
  create_dir "$backup_dir"

  # Backup important system files
  local system_files=(
    "/etc/pacman.conf"
    "/etc/sddm.conf"
    "/etc/X11/xorg.conf.d"
  )

  for file in "${system_files[@]}"; do
    if [ -e "$file" ]; then
      backup "$file"
    fi
  done
}

#===============================================================================
# Copy functions
#===============================================================================
copy_file() {
  local source="$1"
  local dest="$2"
  local rsync_flags="-av --delete --ignore-existing"

  if [ "$VERBOSE" -eq 1 ]; then
    rsync_flags="$rsync_flags -v"
  fi

  if [ "$FORCE" -eq 1 ]; then
    rsync_flags="$rsync_flags --force"
  fi

  if [ ! -e "$source" ]; then
    log "error" "Source does not exist: $source"
    return 1
  fi

  # Create destination directory
  local dest_dir=$(dirname "$dest")
  create_dir "$dest_dir"

  # Backup if file exists
  if [ -f "$dest" ] || [ -L "$dest" ]; then
    backup "$dest"
  fi

  # Copy using rsync
  if [ -d "$source" ]; then
    rsync $rsync_flags "$source/" "$dest/"
  else
    rsync $rsync_flags "$source" "$dest"
  fi

  # Set permissions if SSH config
  if [[ "$dest" =~ \.ssh/ ]]; then
    set_ssh_permissions "$dest"
  fi

  log "info" "Copied $source to $dest"
  return 0
}

exclude_files() {
  local exclude_patterns=(
    "*.swp"
    "*.swo"
    "*.bak"
    "*.tmp"
  )

  for pattern in "${exclude_patterns[@]}"; do
    find "$DOTFILES_DIR" -type f -name "$pattern" -delete
  done
}

#===============================================================================
# Configuration file mapping (source:destination)
#===============================================================================
# These are relative paths from the dotfiles repo to the home directory
declare -A HOME_CONFIG_FILES=(
  [".zshrc"]=".zshrc"
  [".bashrc"]=".bashrc"
  [".p10k.zsh"]=".p10k.zsh"
  [".gitconfig"]=".gitconfig"
  [".npmrc"]=".npmrc"
  [".ssh/id_ed25519"]=".ssh/id_ed25519"
  [".ssh/id_ed25519.pub"]=".ssh/id_ed25519.pub"
  [".ssh/config"]=".ssh/config"
)

#===============================================================================
# Configuration directories mapping (source:destination)
#===============================================================================
# These are relative paths from the ~/.config directory to the dotfiles repo
# The destination paths are relative to the files directory
declare -A CONFIG_DIRS=(
  ["hypr"]="hypr"
  ["kitty"]="kitty"
  ["cava"]="cava"
  ["warp-terminal"]="warp-terminal"
  ["matugen"]="matugen"
  ["sddm"]="sddm"
  ["Ax-Shell"]="Ax-Shell"
  ["nvim"]="nvim"
  ["Code - OSS"]="Code - OSS"
)

#===============================================================================
# Print usage information
#===============================================================================
usage() {
  echo -e "${BLUE}Usage:${NC} $0 [options] command"
  echo
  echo -e "${BLUE}Commands:${NC}"
  echo "  init       Initialize dotfiles repository with existing configs"
  echo "  install    Install dotfiles to the system"
  echo "  update     Update repository with latest local changes"
  echo "  list       List managed dotfiles"
  echo "  help       Show this help message"
  echo
  echo -e "${BLUE}Options:${NC}"
  echo "  -v, --verbose   Enable verbose output"
  echo "  -f, --force     Force overwrite without confirmation"
  echo "  -h, --help      Show this help message"
  echo
  echo -e "${BLUE}Examples:${NC}"
  echo "  $0 init             # Initialize repository with existing configs"
  echo "  $0 install          # Install dotfiles to system"
  echo "  $0 update           # Update repository with local changes"
  echo "  $0 -f install       # Force install without confirmation"
  echo
}

#===============================================================================
# Show interactive menu
#===============================================================================
show_menu() {
  local options=(
    "init" "Initialize dotfiles repository with existing configs"
    "install" "Install dotfiles to the system"
    "update" "Update repository with latest local changes"
    "list" "List managed dotfiles"
    "exit" "Exit the script"
  )

  while true; do
    clear
    echo -e "${BLUE}Dotfiles Management Script${NC}"
    echo "============================="
    echo

    # Print menu options
    for i in "${!options[@]}"; do
      if [ $((i % 2)) -eq 0 ]; then
        echo -e "${BLUE}[$((i / 2 + 1))]${NC} ${options[$i]} - ${options[$((i + 1))]}"
      fi
    done

    echo
    echo -e "${BLUE}Options:${NC}"
    echo "  -v, --verbose   Enable verbose output"
    echo "  -f, --force     Force overwrite without confirmation"
    echo "  -h, --help      Show this help message"

    echo
    echo -n "${BLUE}Enter your choice (1-5) or option (-v, -f, -h): ${NC}"
    read -r choice

    # Handle options
    case "$choice" in
    -v | --verbose)
      VERBOSE=1
      continue
      ;;
    -f | --force)
      FORCE=1
      continue
      ;;
    -h | --help)
      usage
      continue
      ;;
    esac

    # Handle menu choices
    case "$choice" in
    1)
      COMMAND="init"
      break
      ;;
    2)
      COMMAND="install"
      break
      ;;
    3)
      COMMAND="update"
      break
      ;;
    4)
      COMMAND="list"
      break
      ;;
    5)
      exit 0
      ;;
    *)
      echo -e "${RED}Invalid choice. Please try again.${NC}"
      sleep 2
      ;;
    esac
  done
}

#===============================================================================
# Print log message
#===============================================================================
log() {
  local level="$1"
  local message="$2"
  local caller="$(caller 1 | awk '{print $2}')"
  local timestamp
  timestamp=$(date '+%Y-%m-%d %H:%M:%S')

  # Use the appropriate color function based on the log level
  case "$level" in
    error) error "${caller}: ${message}" ;;
    warn) warn "${caller}: ${message}" ;;
    success) success "${caller}: ${message}" ;;
    info) info "${caller}: ${message}" ;;
    debug) debug "${caller}: ${message}" ;;
    trace) trace "${caller}: ${message}" ;;
    *) echo "${timestamp} [${level}] ${caller}: ${message}" ;;
  esac

  # Also write to log file if enabled (without color codes)
  if [ -n "$LOG_FILE" ]; then
    echo "${timestamp} [${level}] ${caller}: ${message}" >>"$LOG_FILE"
  fi
}

#===============================================================================
# Check if running on Arch Linux
#===============================================================================
check_arch_linux() {
  if ! grep -q "Arch Linux" /etc/os-release 2>/dev/null; then
    log "error" "This script is designed for Arch Linux only"
    exit 1
  fi
}

#===============================================================================
# Check required dependencies and install if missing
#===============================================================================
check_dependencies() {
  local deps=("git" "ln" "rsync")
  local missing=()
  local installed=()

  # Check which dependencies are missing
  for dep in "${deps[@]}"; do
    if ! command -v "$dep" &>/dev/null; then
      missing+=("$dep")
    else
      installed+=("$dep")
    fi
  done

  if [ ${#missing[@]} -gt 0 ]; then
    log "warn" "Missing dependencies: ${missing[*]}"
    log "info" "Installing missing dependencies..."

    # Run sudo pacman -S with the missing dependencies
    if sudo pacman -S --noconfirm "${missing[@]}"; then
      log "info" "Dependencies installed successfully"
    else
      log "error" "Failed to install dependencies"
      exit 1
    fi
  fi

  if [ ${#installed[@]} -gt 0 ]; then
    log "info" "Already installed: ${installed[*]}"
  fi

  log "info" "All required dependencies are installed"
}

# Backup a file or directory using rsync
backup() {
  local path="$1"
  local backup_path="$BACKUP_DIR/$(basename "$path")"

  if [ ! -e "$path" ]; then
    log "debug" "Nothing to backup at $path"
    return 0
  fi

  # Create backup directory structure
  mkdir -p "$BACKUP_DIR"

  # Use rsync for efficient backup
  rsync -av --delete "$path" "$backup_path"
  log "info" "Backed up $path to $backup_path"
}

# Create directory if it doesn't exist
create_dir() {
  local dir="$1"
  if [ ! -d "$dir" ]; then
    mkdir -p "$dir"
    log "debug" "Created directory: $dir"
  fi
}

# Copy a file or directory
copy_file() {
  local source="$1"
  local dest="$2"
  local cache_key="$source:$dest"

  # Check cache
  if [ -f "$CACHE_FILE" ] && [ "$FORCE" -eq 0 ]; then
    local cached_mtime=$(grep -m1 "$cache_key" "$CACHE_FILE" 2>/dev/null | cut -d: -f2)
    if [ -n "$cached_mtime" ]; then
      local source_mtime=$(stat -c %Y "$source" 2>/dev/null)
      if [ -n "$source_mtime" ] && [ "$source_mtime" -le "$cached_mtime" ]; then
        log "debug" "Skipping copy of $source (up to date)"
        return 0
      fi
    fi
  fi

  # For home config files, source is already a full path
  if [[ "$source" == "$DOTFILES_DIR"/* ]]; then
    local repo_path="$source"
    local system_path="$HOME/$(basename "$source")"
  else
    local repo_path="$DOTFILES_DIR/config/$source"
    local system_path="$CONFIG_DIR/$dest"
  fi

  # Check if source exists and is readable
  if [ ! -e "$repo_path" ]; then
    log "error" "Source does not exist: $repo_path"
    return 1
  elif [ ! -r "$repo_path" ]; then
    log "error" "Source is not readable: $repo_path"
    return 1
  fi

  # Create destination directory if it doesn't exist
  local dest_dir=$(dirname "$system_path")
  create_dir "$dest_dir"

  # Backup existing file if it exists and is writable
  if [ -f "$system_path" ] || [ -L "$system_path" ]; then
    if [ ! -w "$system_path" ]; then
      log "warn" "Destination is not writable: $system_path"
      return 1
    fi
    backup "$system_path"
  fi

  # Use rsync for copying with appropriate flags
  local rsync_flags="-av --delete --progress"

  # Add --delete flag only for directories
  if [ ! -d "$repo_path" ]; then
    rsync_flags="$rsync_flags --no-delete"
  fi

  # Add verbose flag if enabled
  if [ "$VERBOSE" -eq 1 ]; then
    rsync_flags="$rsync_flags -v"
  fi

  # Copy using rsync with retries
  local retries=3
  local attempt=1
  while [ $attempt -le $retries ]; do
    if rsync $rsync_flags "$repo_path" "$system_path"; then
      # Update cache
      echo "$cache_key:$(stat -c %Y "$system_path")" >"$CACHE_FILE"
      log "info" "Successfully copied $repo_path to $system_path"
      return 0
    else
      log "warn" "Attempt $attempt/$retries failed. Retrying..."
      attempt=$((attempt + 1))
      sleep 1
    fi
  done

  log "error" "Failed to copy $repo_path after $retries attempts"
  return 1
}

#===============================================================================
# Copy file to dotfiles repository
#===============================================================================
copy_to_repo() {
  local source="$1"
  local dest="$2"

  # For home config files, source is already a full path
  if [[ "$source" == "$HOME"/* ]]; then
    local system_path="$source"
    local repo_path="$DOTFILES_DIR/$(basename "$source")"
  else
    local system_path="$CONFIG_DIR/$source"
    local repo_path="$DOTFILES_DIR/$dest"
  fi

  if [ ! -e "$system_path" ]; then
    log "error" "Source does not exist: $system_path"
    return 1
  fi

  create_dir "$(dirname "$repo_path")"

  # Copy using rsync for better efficiency
  rsync -av "$system_path" "$repo_path"
  log "info" "Copied $system_path to $repo_path"
}

#===============================================================================
# Install base packages and dependencies
#===============================================================================
install_base_packages() {
  log "info" "Installing base packages..."

  # Essential packages from official repositories
  local official_packages=(
    "base-devel"
    "hyprland"
    "hyprlock"
    "hypridle"
    "sddm"
    "kitty"
    "nautilus"
    "zsh"
    "gnome-keyring"
    "ttf-jetbrains-mono"
    "ttf-fira-code"
    "ttf-hack"
    "ttf-roboto"
    "gst-plugins-base"
    "gst-plugins-good"
    "gst-plugins-bad"
    "gst-plugins-ugly"
    "gst-libav"
  )

  # Install official packages
  if sudo pacman -S --noconfirm "${official_packages[@]}"; then

    # Install powerlevel10k font assets if not already installed
    if [ ! -d "$HOME/.oh-my-zsh/custom/themes/powerlevel10k-media" ]; then
      log "info" "Installing powerlevel10k font assets..."
      git clone --depth=1 https://github.com/romkatv/powerlevel10k-media.git "$HOME/.oh-my-zsh/custom/themes/powerlevel10k-media"
    fi

    # Configure gnome-keyring as default keyring
    log "info" "Configuring gnome-keyring as default keyring..."
    mkdir -p "$HOME/.config/environment.d"
    echo "GNOME_KEYRING_CONTROL=1" >>"$HOME/.config/environment.d/keyring.conf"
    echo "SSH_AUTH_SOCK=$XDG_RUNTIME_DIR/gcr/ssh" >>"$HOME/.config/environment.d/keyring.conf"

    log "success" "Base packages installed successfully"
  else
    log "error" "Failed to install base packages"
    exit 1
  fi

  # AUR packages
  local aur_packages=(
    "ttf-source-code-pro"
    "ttf-consolas"
    "ttf-monaco"
    "ttf-meslo-nerd-font"
    "warp-terminal-bin"
    "microsoft-edge-stable-bin"
  )

  # Install yay if not already installed
  if ! command -v yay &>/dev/null; then
    log "info" "Installing yay..."

    sudo pacman -S --noconfirm base-devel

    # Clone yay repository
    git clone https://aur.archlinux.org/yay-bin.git /tmp/yay-bin
    cd /tmp/yay-bin

    # Build and install yay
    makepkg -si --noconfirm

    # Clean up
    cd - >/dev/null
    rm -rf /tmp/yay-bin
  fi

  # Install AUR packages
  log "info" "Installing AUR packages..."
  yay -S --noconfirm "${aur_packages[@]}"

  # Install oh-my-zsh and powerlevel10k if not already installed
  if [ ! -d "$HOME/.oh-my-zsh" ]; then
    log "info" "Installing oh-my-zsh..."
    sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended
  fi

  if [ ! -d "$HOME/.oh-my-zsh/custom/themes/powerlevel10k" ]; then
    log "info" "Installing powerlevel10k..."
    git clone --depth=1 https://github.com/romkatv/powerlevel10k.git "$HOME/.oh-my-zsh/custom/themes/powerlevel10k"
  fi

  # Set zsh as default shell
  if [ "$SHELL" != "/usr/bin/zsh" ]; then
    log "info" "Setting zsh as default shell..."
    sudo chsh -s /usr/bin/zsh "$USER"
  fi

  # Install Ax-Shell if not already installed
  if [ ! -d "$HOME/.config/Ax-Shell" ]; then
    log "info" "Installing Ax-Shell..."
    curl -fsSL https://raw.githubusercontent.com/Axenide/Ax-Shell/main/install.sh | bash
  fi

  # Configure SDDM for Hyprland
  log "info" "Configuring SDDM for Hyprland..."

  # Create SDDM configuration directory if it doesn't exist
  sudo mkdir -p /etc/sddm.conf.d

  # Create SDDM configuration
  sudo tee /etc/sddm.conf.d/hyprland.conf >/dev/null <<'EOF'
    [General]
    Current=Hyprland

    [Theme]
    Current=breeze

    [X11]
    ServerArguments=-nolisten tcp

    [Autologin]
    User=$USER
    Session=Hyprland
EOF

  # Create Hyprland session file
  # Create xsessions directory if it doesn't exist
  sudo mkdir -p /usr/share/xsessions
  sudo tee /usr/share/xsessions/hyprland.desktop >/dev/null <<'EOF'
[Desktop Entry]
Name=Hyprland
Comment=Hyprland
Exec=hyprland
TryExec=hyprland
Type=Application
Keywords=wayland;window manager;hyprland;
EOF

  # Create Hyprlock service file
  sudo tee /etc/systemd/system/hyprlock.service >/dev/null <<'EOF'
[Unit]
Description=Hyprlock Service
After=display-manager.service

[Service]
Type=oneshot
ExecStart=/usr/bin/hyprlock

[Install]
WantedBy=display-manager.service
EOF

  # Enable Hyprlock service
  sudo systemctl enable hyprlock.service

  log "success" "SDDM configured for Hyprland with Hyprlock"
}

#===============================================================================
# Main Functions
#===============================================================================
# Initialize dotfiles repository with existing configs
init_dotfiles() {
  log "info" "Initializing dotfiles repository..."

  # Create repository structure
  mkdir -p "$DOTFILES_DIR/home"
  mkdir -p "$DOTFILES_DIR/config"

  # Copy home config files
  for src in "${!HOME_CONFIG_FILES[@]}"; do
    local dest="${HOME_CONFIG_FILES[$src]}"
    local system_path="$HOME/$dest"
    local repo_path="$DOTFILES_DIR/home/$src"

    if [ -e "$system_path" ]; then
      copy_file "$system_path" "$repo_path"
    else
      log "warn" "File not found: $system_path"
    fi
  done

  # Copy config directories
  for src in "${!CONFIG_DIRS[@]}"; do
    local dest="${CONFIG_DIRS[$src]}"
    local system_path="$CONFIG_DIR/$dest"
    local repo_path="$DOTFILES_DIR/config/$src"

    if [ -e "$system_path" ]; then
      copy_file "$system_path" "$repo_path"
    else
      log "warn" "Directory not found: $system_path"
    fi
  done

  log "info" "Repository initialized at $DOTFILES_DIR"
  log "info" "You might want to commit the changes:"
  log "info" "git -C \"$DOTFILES_DIR\" add ."
  log "info" "git -C \"$DOTFILES_DIR\" commit -m \"Initial commit\""
}

install_dotfiles() {
  log "info" "Installing dotfiles..."

  # Create backup directory for install
  create_dir "$BACKUP_INSTALL_DIR"

  # Backup existing system files before installation
  backup_system_config "$BACKUP_TYPE_INSTALL"

  # Install home config files using HOME_CONFIG_FILES mapping
  log "info" "Installing home config files..."
  for src in "${!HOME_CONFIG_FILES[@]}"; do
    local dest="${HOME_CONFIG_FILES[$src]}"
    local source_path="$DOTFILES_DIR/$src"
    local target_path="$HOME/$dest"

    if [ -e "$source_path" ]; then
      # Backup existing file on system
      if [ -e "$target_path" ]; then
        backup "$target_path" "$BACKUP_TYPE_INSTALL"
      fi

      log "info" "Installing $dest"
      copy_file "$source_path" "$target_path"
    else
      log "warn" "Source file not found: $source_path"
    fi
  done

  # Install config directories using CONFIG_DIRS mapping
  log "info" "Installing config directories..."
  for src in "${!CONFIG_DIRS[@]}"; do
    local dest="${CONFIG_DIRS[$src]}"
    local source_path="$DOTFILES_DIR/$dest"
    local target_path="$CONFIG_DIR/$src"

    if [ -e "$source_path" ]; then
      # Backup existing directory on system
      if [ -d "$target_path" ]; then
        backup "$target_path" "$BACKUP_TYPE_INSTALL"
      fi

      log "info" "Installing $src"
      copy_file "$source_path" "$target_path"

      # Set SSH permissions if needed
      if [ "$src" = "ssh" ]; then
        set_ssh_permissions "$CONFIG_DIR/$src" "$src"
      fi

      # Set SSH permissions for any SSH-related path
      if [[ "$target_path" =~ \.ssh/ ]]; then
        set_ssh_permissions "$HOME/.ssh" "$relative_path"
      fi
    else
      log "warn" "Source directory not found: $source_path"
    fi
  done

  # Set SSH permissions for config directory
  set_ssh_permissions "$CONFIG_DIR/.ssh" "config directory"

  log "success" "Dotfiles installation completed"

  # Set up SDDM for Hyprland
  log "info" "Setting up SDDM for Hyprland..."

  # Create SDDM configuration directory if it doesn't exist
  sudo mkdir -p /etc/sddm.conf.d

  # Backup existing SDDM config if it exists
  local system_sddm_conf="/etc/sddm.conf.d/wayland.conf"
  if [ -e "$system_sddm_conf" ]; then
    backup "$system_sddm_conf" "$BACKUP_TYPE_INSTALL"
  fi

  # Create SDDM configuration
  sudo tee "$system_sddm_conf" >/dev/null <<EOF
    [General]
    DisplayServer=wayland

    [Wayland]
    SessionDir=/usr/share/wayland-sessions

    [Autologin]
    User=$(whoami)
    Session=hyprland.desktop
    Relogin=false
EOF

  log "info" "SDDM configured for Hyprland"

  # Enable SDDM service
  log "info" "Enabling SDDM service..."
  sudo systemctl enable sddm.service

  log "info" "Dotfiles installation complete"
}

# Update repository with latest local changes
update_repo() {
  log "info" "Updating repository with latest local changes..."

  # Create backup directory for update
  create_dir "$BACKUP_UPDATE_DIR"

  # Copy home config files using HOME_CONFIG_FILES mapping
  for src in "${!HOME_CONFIG_FILES[@]}"; do
    local dest="${HOME_CONFIG_FILES[$src]}"
    local system_path="$HOME/$dest"
    local repo_path="$DOTFILES_DIR/$src"

    if [ -e "$system_path" ]; then
      # Backup existing file in repository
      if [ -e "$repo_path" ]; then
        backup "$repo_path" "$BACKUP_TYPE_UPDATE"
      fi

      copy_file "$system_path" "$repo_path"
    else
      log "warn" "File not found: $system_path"
    fi
  done

  # Copy config directories using CONFIG_DIRS mapping
  for src in "${!CONFIG_DIRS[@]}"; do
    local dest="${CONFIG_DIRS[$src]}"
    local system_path="$CONFIG_DIR/$src"
    local repo_path="$DOTFILES_DIR/$dest"

    if [ -e "$system_path" ]; then
      # Backup existing directory in repository
      if [ -d "$repo_path" ]; then
        backup "$repo_path" "$BACKUP_TYPE_UPDATE"
      fi

      log "info" "Copying config directory: $src"
      # Use rsync directly instead of copy_to_repo for better control
      local rsync_flags="-av --delete"

      # Create destination directory
      create_dir "$repo_path"

      # Copy directory contents
      rsync $rsync_flags "$system_path/" "$repo_path/"
    else
      log "warn" "Directory not found: $system_path"
    fi
  done

  # Copy additional config files
  for config in "$HOME/.ssh" "$HOME/.gitconfig" "$HOME/.bashrc" "$HOME/.zshrc"; do
    if [ -e "$config" ]; then
      # Remove $HOME from the path to create relative path
      relative_path="${config#$HOME/}"
      repo_path="$DOTFILES_DIR/$relative_path"

      # Create target directory if it doesn't exist
      repo_dir=$(dirname "$repo_path")
      create_dir "$repo_dir"

      # Copy file or directory to repository
      log "info" "Copying $relative_path to repository"

      # Use rsync for copying with appropriate flags
      local rsync_flags="-av --delete"

      # Add --delete flag only for directories
      if [ ! -d "$config" ]; then
        rsync_flags="$rsync_flags --no-delete"
      fi

      # Copy using rsync
      rsync $rsync_flags "$config" "$repo_path"

      # Set SSH permissions for repository
      if [[ "$repo_path" =~ \.ssh/ ]]; then
        set_ssh_permissions "$DOTFILES_DIR/.ssh" "$relative_path"
      fi
    fi
  done

  log "success" "Repository update completed"
}

set_ssh_permissions() {
  local ssh_dir="$1"
  local description="$2"

  if [ -z "$ssh_dir" ]; then
    log "error" "SSH directory path is required"
    return 1
  fi

  if [ ! -d "$ssh_dir" ]; then
    log "warn" "SSH directory does not exist: $ssh_dir"
    return 0
  fi

  # Verify ownership
  if [ "$(stat -c '%U' "$ssh_dir")" != "$USER" ]; then
    log "warn" "SSH directory not owned by current user. Attempting to fix..."
    if ! sudo chown -R "$USER" "$ssh_dir"; then
      log "error" "Failed to change ownership of SSH directory"
      return 1
    fi
  fi

  # Set proper permissions
  log "info" "Setting SSH permissions for $description"
  chmod 700 "$ssh_dir"

  # Set permissions for specific files
  local files=(
    "config" "config.*"
    "id_*" "id_*.pub"
    "known_hosts" "known_hosts.old"
  )

  for file in "${files[@]}"; do
    if [ -f "$ssh_dir/$file" ]; then
      if [[ "$file" =~ \.pub$ ]]; then
        chmod 644 "$ssh_dir/$file"
      else
        chmod 600 "$ssh_dir/$file"
      fi
    fi
  done

  # Verify permissions
  if ! stat -c '%a' "$ssh_dir" | grep -q '^700$'; then
    log "warn" "Failed to set proper permissions for SSH directory"
    return 1
  fi

  log "success" "SSH permissions set successfully"
  return 0
}

#===============================================================================
# List managed dotfiles
#===============================================================================
list_dotfiles() {
  log "info" "Managed home config files:"
  for src in "${!HOME_CONFIG_FILES[@]}"; do
    local dest="${HOME_CONFIG_FILES[$src]}"
    local repo_path="$DOTFILES_DIR/home/$src"
    local system_path="$HOME/$dest"

    if [ -e "$repo_path" ]; then
      echo -e "${BLUE}$system_path${NC} -> ${GREEN}$repo_path${NC}"
    else
      echo -e "${BLUE}$system_path${NC} -> ${RED}Not in repository${NC}"
    fi
  done

  echo
  log "info" "Managed config directories:"
  for src in "${!CONFIG_DIRS[@]}"; do
    local dest="${CONFIG_DIRS[$src]}"
    local repo_path="$DOTFILES_DIR/config/$src"
    local system_path="$CONFIG_DIR/$dest"

    if [ -e "$repo_path" ]; then
      echo -e "${BLUE}$system_path${NC} -> ${GREEN}$repo_path${NC}"
    else
      echo -e "${BLUE}$system_path${NC} -> ${RED}Not in repository${NC}"
    fi
  done
}

#===============================================================================
# Show interactive menu
#===============================================================================
show_menu() {
  local options=(
    "init" "Initialize dotfiles repository with existing configs"
    "install" "Install dotfiles to the system"
    "update" "Update repository with latest local changes"
    "list" "List managed dotfiles"
    "exit" "Exit the script"
  )

  while true; do
    clear
    echo -e "${BLUE}Dotfiles Management Script${NC}"
    echo "============================="
    echo

    # Print menu options
    for i in "${!options[@]}"; do
      if [ $((i % 2)) -eq 0 ]; then
        echo -e "${BLUE}[$((i / 2 + 1))]${NC} ${options[$i]} - ${options[$((i + 1))]}"
      fi
    done

    echo
    echo -e "${BLUE}Options:${NC}"
    echo "  -v, --verbose   Enable verbose output"
    echo "  -f, --force     Force overwrite without confirmation"
    echo "  -h, --help      Show this help message"

    echo
    echo -n "${BLUE}Enter your choice (1-5) or option (-v, -f, -h): ${NC}"
    read -r choice

    # Handle options
    case "$choice" in
    -v | --verbose)
      VERBOSE=1
      continue
      ;;
    -f | --force)
      FORCE=1
      continue
      ;;
    -h | --help)
      usage
      continue
      ;;
    esac

    # Handle menu choices
    case "$choice" in
    1)
      COMMAND="init"
      break
      ;;
    2)
      COMMAND="install"
      break
      ;;
    3)
      COMMAND="update"
      break
      ;;
    4)
      COMMAND="list"
      break
      ;;
    5)
      exit 0
      ;;
    *)
      echo -e "${RED}Invalid choice. Please try again.${NC}"
      sleep 2
      ;;
    esac
  done
}

#===============================================================================
# Main Script
#===============================================================================
# Parse command-line options
while [[ $# -gt 0 ]]; do
  case "$1" in
  -v | --verbose)
    VERBOSE=1
    shift
    ;;
  -f | --force)
    FORCE=1
    shift
    ;;
  -h | --help)
    usage
    exit 0
    ;;
  *)
    if [ -z "$COMMAND" ]; then
      # If no command was set yet, this is the command
      COMMAND="$1"
    else
      # If command was already set, this is an error
      log "error" "Unknown option: $1"
      usage
      exit 1
    fi
    shift
    ;;
  esac
done

# If no command was specified via arguments, show menu
if [ -z "$COMMAND" ]; then
  show_menu
fi

# Check root and dependencies
check_root
check_dependencies

# Create backup directory
create_dir "$BACKUP_DIR"

# Execute command based on user input
case "$COMMAND" in
init)
  init_dotfiles
  ;;
install)
  # Backup system config before install
  backup_system_config
  install_dotfiles
  verify_installation
  ;;
update)
  exclude_files
  update_repo
  ;;
list)
  list_dotfiles
  ;;
*)
  log "error" "Unknown command: $COMMAND"
  usage
  exit 1
  ;;
esac

# Final cleanup
cleanup
exit 0
